import MainLayout from "../../layouts/MainLayout.astro";

<MainLayout>
# React Hooks
State Hooks
 - useState: 직접 업데이트 할 수 있는 상태 변수를 선언
 - useReducer: 리듀서 함수 내부의 업데이트 로직을 사용해 상태 변수를 선언

Context Hooks

- useContext: 컨텍스트를 읽고 구독

Ref Hooks

- useRef: ref를 선언. 주로 DOM 노드를 담는데 사용
- useImperativeHandle: 컴포넌트에 의해 노출된 ref를 정의. 거의 사용하지 않음

Effect Hooks

- useEffect: 구성요소를 외부 시스템에 연결
- useLayoutEffect: 브라우저가 화면을 다시 그리기 전에 실행됨. 레이아웃 측정 가능.
- useInsertionEffect: React가 DOM을 변경하기 전에 실행. 라이브러리는 여기에 동적 CSS를 삽입할 수 있음

Perfomarnce Hooks

- useMemo: 비용이 많이 드는 계산 결과를 캐싱
- useCallback: 함수 정의를 최적화된 컴포넌트에 전달하기 전에 캐싱
- useTransition: 상태 전환을 논블로킹으로 표시하고 다른 업데이트가 이를 중단하도록 허용할수있음
- useDefferedValue: UI의 중요하지 않은 부분 업데이트를 연기하고 다른 부분이 먼저 업데이트 되도록 할 수 있음

Resource Hooks

- use: Promise또는 context와 같은 리소스의 값을 읽을 수 있음

ETC Hooks

- useDebugValue: custom hook에 대해 devtool 표시 레이블을 정의할 수 있음
- useId: 컴포넌트가 고유 ID를 자신과 연결할 수 있음. 접근성 API와 같이 사용됨
- useSyncExternalStore: 컴포넌트가 외부 저장소를 구독할 수 있도록 함

Custom Hook: 사용자 정의 hook

## useState

```ts
const [state, setState] = useState(initialState);
```

- 배열 구조분해 할당으로 이름 지정

### Parameters

- initialState: 초기 상태값. 초기 렌더링 이후에 무시됨

### Return

- 두 개 값이 있는 배열 리턴

1. 현재 상태.
2. 상태를 다른 값으로 업데이트 하고 다시 렌더링을 트리거 할 수 있는 set 함수:setSomething(nextState)

### Caveats

- 컴포넌트 최상회 수준이나 자체 hook에서만 호출 가능
- set함수는 다음 렌더링에 대한 상태 변수만 업데이트 함.
- state에 제공한 새 값이 Object.is 비교결과가 현재 값과 동일하면 컴포넌트와 하위 항목 리랜더링을 건너뜀.
- 모든 이벤트 핸들러가 실행되고 상태 업데이트를 일괄 처리함. => DOM에 접근하기 위해 업데이트를 강제 해야 하는 경우는 flushSync사용.

## useEffect

```ts
useEffect(setup, dependencies);

useEffect(() => {
  const connection = createConnection(serverUrl, roomId);
  connection.connect();
  return () => {
    connection.disconnect();
  };
}, [serverUrl, roomId]);
```

### Parameters

- setup: Effect의 로직이 포함된 기능. 선택적으로 cleanup 함수를 반환할 수도 있음. 컴포넌트가 DOM에 추가되면 React는 setup기능을 실행함. 변경된 디펜던시를 사용해 리랜더링 할때마다 cleanup 기능을 실행한 후, 새 값을 사용해 setup기능을 실행함. 컴포넌트가 DOM에서 제거된 후에는 cleanup기능을 실행함
- dependencies(optional): 코드 내부에서 참조되는 모든 반응값의 목록. 각 디펜던시를 Object.is 비교를 사용해 이전값과 비교함. 인수를 생략하면 컴포넌트를 렌더링 할때마다 effect가 다시 실행됨.

### Returns

- undefined를 반환함

### Caveats

- 외부 시스템과 동기화하려는게 아니면 useEffect가 필요하지 않을 수 있음
- Effect가 인터렉션과 관련해 화면 페인트 시기를 제어해야 하는 경우 useLayoutEffect를 사용
- Effect는 클라이언트에서만 실행됨. 서버렌더링 중에는 실행되지 않음.

## useRef

```ts
const ref = useRef(initialValue);
```

### Parameters

- initialValue: ref 객체의 속성 초기값

### Return

- 단일 속성을 가진 객체 반환
- current: 처음에 initialValue가 설정됨

### Caveats

- 속성을 변경할 수 있음. state와 달리 변경 가능함. 하지만 렌더링에 사용되는 object를 가지고 있는 경우 변경하면 안됨.
- 속성을 변경해도 컴포넌트를 다시 렌더링하지 않음. ref는 일반 JS 객체라서 리액트는 언제 변경됐는지 알지 못함.
- 초기화를 제외하고는 렌더링 중에는 읽거나 쓰면 안됨. 컴포넌트 동작을 예측할 수 없어짐.

## forwardRef

- 컴포넌트가 ref를 사용하여 DOM노드를 상위 컴포넌트에 노출시킬 때 사용한다

```ts
const SomeComponent = forwardRef(render);

import { forwardRef } from "react";

const MyInput = forwardRef(function MyInput(props, ref) {
  // ...
});
```

### Parameters

- render: 컴포넌트의 렌더링 기능. 리액트는 props를 사용해 이 함수를 호출하고, ref 컴포넌트가 상위 요소로부터 받은 것을 사용함. 반환하는 JSX는 컴포넌트의 return이 됨

### Returns

- JSX에서 렌더링가능한 리액트 컴포넌트 반환.
- 일반 리액트 컴포넌트와 달리 return된 컴포넌트도 ref prop을 받을 수 있음.

## useMemo

- 리랜더링 사이에 계산 결과를 캐시할 수 있음

```ts
const cachedValue = useMemo(calculateValue, dependencies);

import { useMemo } from "react";

function TodoList({ todos, tab }) {
  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);
  // ...
}
```

### Parameters

- calculateValue: 캐시하려는 값을 계산하는 함수
- dependencies: 코드 내부에서 참조하는 반응값의 목록. Object.is로 디펜던시 비교.

### Returns

- 초기 렌더링 시 인수없이 calculateValue 호출한 결과를 반환함
- 다음 렌더링 중에는 마지막 렌더링에서 이미 저장된 값을 반환하거나(디펜던시가 변경되지 않은 경우), 다시 호출해 calculateValue 결과를 반환함.

### Caveats

- 리액트는 특별한 이유가 없는 한 캐시된 값을 버리지 않음.
- 첫 번째 렌더링이 더 빨라지지는 않음. 불필요한 업데이트 작업을 건너뛰는 데 도움이 됨.

## memo

- prop이 변경되지 않은 경우, 컴포넌트를 다시 렌더링하는 걸 건너뛸 수 있음
- 컴포넌트를 래핑해 컴포넌트의 memoized 버전을 얻을 수 있음
- 성능 최적화이지 보장이 아님

```ts
const MemoizedComponent = memo(SomeComponent, arePropsEqual);

import { memo } from "react";
const SomeComponent = memo(function SomeComponent(props) {
  // ...
});
```

### Parameters

- Component: memoize 하고 싶은 컴포넌트. 컴포넌트를 수정하지 않고 메모된 새 컴포넌트를 반환함. forwardRef 허용됨
- arePropsEqual(optional): prop이 이전 prop과 새 prop이 동일한 경우 반환해야 함. 일반적으로 지정하지 않음.

### Returns

- 새로운 리액트 컴포넌트를 리턴함.

## flushSync

- React가 보류 중인 모든 작업을 flush하고 DOM을 동기식으로 업데이트하도록 호출함
- 대부분의 경우 flushSync를 피할 수 있음. 최후의 수단으로 사용할 것.

```ts
import { flushSync } from "react-dom";

flushSync(() => {
  setSomething(123);
});
```

### Parameters

- callback: 즉시 이 콜백을 호출하고 모든 업데이트를 동기적으로 flush함. 보류중인 업데이트, effect를 flush할 수도 있음.

### Returns

- undefined return

### Caveats

- 성능이 크게 저하될 수 있음. 드물게 사용할 것.
- 보류중인 Suspense boundary가 fallback 상태를 표시하도록 강제할 수 있음
- 보류중인 effect를 실행하고, 반환되기 전에 포함된 모든 업데이트를 적용할 수 있음.

## useSyncExternalStore

- 외부 저장소를 구독할 수 있게 해줌
- subscribe 함수는 store를 구독하고, 구독을 취소하는 함수를 반환해야 함.
- getSnapshot 함수는 store에서 데이터의 snapshot을 읽어야 함.

```ts
const snapshot = useSyncExternalStore(
  subscribe,
  getSnapshot,
  getServerSnapshot
);
```

### Parameters

- subscribe: callback argument를 가져와 store에 구독하는 함수. store가 변경되면 callback을 부름. 컴포넌트가 다시 렌더링 됨. 구독을 cleanup 하는 함수를 반환해야 함.
- getSnapshot: 컴포넌트에 필요한 store의 데이터 스냅샷을 반환하는 함수. store가 변경되지 않는 동안은 동일한 값을 반환해야 함.
- getServerSnapshot(optional): store에 있는 데이터의 초기 스냅샷을 반환함. 서버 렌더링 및 클라이언트에서 서버 렌더링 콘턴츠를 하이드레이션 하는 동안에만 사용됨.

### Returns

- 렌더링 로직에 사용할 수 있는 store의 현재 스냅샷

### Caveats

- getSnapshot에서 반환한 store 스냅샷은 변경할 수 없어야 함.
- 다시 렌더링하는 동안 다른 subscribe함수가 전달되면, 리액트는 새로 전달된 함수를 사용해 store를 다시 구독함.

## useImperativeHandle

- ref로 노출된 handle을 사용자가 정의할 수 있게 해줌

```ts
useImperativeHandle(ref, createHandle, dependencies);

import { forwardRef, useImperativeHandle } from "react";

const MyInput = forwardRef(function MyInput(props, ref) {
  useImperativeHandle(
    ref,
    () => {
      return {
        // ... your methods ...
      };
    },
    []
  );
});
```

### Parameters

- ref: forwardRef의 render함수 두번째 인수로 받음.
- createHandle: 인수를 사용하지 않고 노출시키려는 ref handle을 반환하는 함수
- dependencies(optional): 코드 내부에서 참조하는 모든 반응값의 목록.

### Returns

- undefined return

## useLayoutEffect

- useLayoutEffect는 성능이 저하될 수 있다. 가능하면 useEffect를 쓰자.
- 브라우저가 화면을 다시 그리기 전에 레이아웃을 측정할 수 있게 해줌.

```ts
useLayoutEffect(setup, dependencies);
```

```ts
import { useState, useRef, useLayoutEffect } from "react";

function Tooltip() {
  const ref = useRef(null);
  const [tooltipHeight, setTooltipHeight] = useState(0);

  useLayoutEffect(() => {
    const { height } = ref.current.getBoundingClientRect();
    setTooltipHeight(height);
  }, []);

  // ...
}
```

### Parameters

- setup: Effect의 로직이 포함된 기능. cleanup 함수를 반환할 수도 있음. 컴포넌트가 DOM에 추가되기 전에 리액트는 setup 기능을 실행함. 변경된 디펜던시를 사용해 다시 렌더링할때마다 리액트는 먼저 이전값을 사용해 cleanup을 실행하고, 새 값을 사용해 setup을 실행함.
- dependencies(optional): 코드 내부에서 사용하는 모든 반응값의 목록.

### Return

- undefined return

### Caveats

- Effect는 클라이언트에서만 실행됨.
- useLayoutEffect 내부 코드와 여기에 예약된 모든 상태 업데이트는 브라우저가 화면을 다시 그리는걸 차단함(paint 차단). 과도하게 사용하면 앱 속도가 느려질 수 있으니 가능하면 useEffect를 사용할 것.
- useEffect를 사용하는 경우, React는 브라우저가 useEffect 내부의 상태 업데이트를 처리하기 전에 화면을 그리도록 해서 layout 조정전에 그린 화면이 보일 수 있다.

## useInsertionEffect

- CSS-in-JS 라이브러리 사용자를 위한 것(동적 스타일 삽입).
- layout effect가 실행되기 전에 DOM에 요소를 삽입할 수 있다.

```ts
useInsertionEffect(setup, dependencies);
```

```ts
import { useInsertionEffect } from "react";

// Inside your CSS-in-JS library
function useCSS(rule) {
  useInsertionEffect(() => {
    // ... inject <style> tags here ...
  });
  return rule;
}
```

### Parameters

- setup: Effect의 로직이 포함된 기능.
- dependencies(optional): 코드 내부에서 참조하는 모든 반응값의 목록.

### Return

- undefined return

### Caveats

- Effect는 클라이언트에서만 실행됨.
- useInsertionEffect 내부에서는 state를 업데이트 할 수 없음.
- 시간이 지나도 ref는 첨부되지 않는다.
- DOM이 업데이트 되기 전이나 후에 실행될 수 있다. 특정 시간에 업데이트되는 DOM에 의존해서는 안된다.
- 모든 Effect에 대한 cleanup을 실행하고, 모든 Effect에 대한 setup을 수행하는 다른 종류의 Effect와는 달리, 한번에 하나의 컴포넌트를 정의하고 설정함. 이로 인해 cleanup, setup 설정이 interleaving됨.

## useReducer

- 컴포넌트에 reducer를 추가할 수 있는 hook.

```ts
const [state, dispatch] = useReducer(reducer, initialArg, init);
```

```ts
import { useReducer } from "react";

function reducer(state, action) {
  switch (action.type) {
    case "incremented_age": {
      return {
        name: state.name,
        age: state.age + 1,
      };
    }
    case "changed_name": {
      return {
        name: action.nextName,
        age: state.age,
      };
    }
  }
  throw Error("Unknown action: " + action.type);
}

function MyComponent() {
  const [state, dispatch] = useReducer(reducer, { age: 42 });
  // ...
}

function handleClick() {
  dispatch({ type: "incremented_age" });
  // ...
}
```

### Parameters

- reducer: state가 업데이트 되는 방법을 지정하는 reducer 함수. 순수함수, state와 action을 인수로 가져와야하고, 다음 state를 반환해야 한다.
- initialArg: 초기 state가 계산되는 값.
- init(optional): 초기 상태를 반환해야 하는 초기화 함수. 지정되지 않은 경우 초기 상태는 initialArg로 설정됨. 그렇지 않으면 초기 상태는 init(initialArg)호출 결과로 설정됨.

- init 함수를 전달하면 init 함수는 초기화 중에만 실행됨. 컴포넌트가 리랜더링 될 때는 실행되지 않음.
- init 함수 없이 init(initialArg)를 initialArg에 초기 상태를 직접 전달하면 모든 렌더링에서 함수가 실행됨. 동작에 눈에 띄는 차이는 없지만 효율성이 떨어짐.

### Return

- [currentState, dispatch] 반환.
- currentState: 첫번째 렌더링 중에는 initialArg / init(initialArg)로 설정됨.
- dispatch: state를 다른 값으로 업데이트하고 다시 렌더링을 트리거 할 수 있는 함수.

- dispatch(action)은 사용자가 수행한 작업을 받음. return 값 없음.
- dispatch 함수는 다음 렌더링에 대한 staet 변수만 업데이트함.

## useContext

- 컴포넌트의 context를 읽고 구독할 수 있다.

```ts
const value = useContext(SomeContext);
```

```ts
import { useContext } from "react";

function MyComponent() {
  const theme = useContext(ThemeContext);
  // ...
}
```

### Parameters

- someContext: createContext를 사용해 만든 컨텍스트. 컨텍스트 자체는 정보를 보유하지 않으며, 컴포넌트에서 제공하거나 읽을 수 있는 정보종류만 나타낸다.

### Return

- 컴포넌트에 대한 컨텍스트 값을 반환함. 호출한 컴포넌트 위에 트리에서 가장 가까운 SomeConent.createContext로 전달되는 것으로 결정됨.
- createcontext에서 반환한 값은 항상 최신 상태이다. 리액트는 컨텍스트가 변경되면 컨텍스트를 읽는 컴포넌트를 자동으로 다시 렌더링한다.

### Caveats

- 컴포넌트 안에서 호출된 useContext()는 같은 컴포넌트에서 반환된 provider의 영향을 받지 않는다. useContext() 호출을 수행하는 컴포넌트 위의 <Context.Provider>가 있어야 한다.

## createContext

```ts

```

### Parameters

### Return

### Caveats

## useCallback

```ts

```

### Parameters

### Return

### Caveats

## useTransition

```ts

```

### Parameters

### Return

### Caveats

## startTransition

```ts

```

### Parameters

### Return

### Caveats

</MainLayout>
